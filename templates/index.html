<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel= "stylesheet" type= "text/css" href= "{{ url_for('static',filename='styles/index.css') }}">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
        <title>3d-ish MineSweeper</title>
        <style>
            {{css | safe}}
        </style>
    </head>
    <body>
      <div class="statsbox" id="statsbox">
        üö© <span id="flags">{{flagged}}</span>/<span id="total">{{totalflags}}</span><br><br>
        ‚è≤Ô∏è <span id="time">0</span> s <br><br><br>
        <button id="togglemode">Dark Mode</button>
      </div>
      <button id="minimize-btn" class="minimize" onclick="toggleSettings()"><p>-</p></button>
      <button id="minimize-btn2" class="minimize" onclick="toggleSettings2()"><p>-</p></button>
      <div class="settingsbox" id="settings-box">
        Choose Level: <br><br>
        <button id="tutorial-btn" onclick="setLevel(0)">Tutorial</button><br><br>
        <button id="beginner-btn" onclick="setLevel(1)">Beginner</button><br><br>
        <button id="intermediate-btn" onclick="setLevel(2)">Intermediate</button><br><br>
        <button id="expert-btn" onclick="setLevel(3)">Expert</button>
      </div>
      <div class="helppopup" id="helppopup">
        <p>?</p>
    </div>
    <div class="bugpopup" id="bugpopup">
      <p>üëæ</p>
  </div>
    <!-- Hidden popup with game tips -->
    <div class="popup-overlay" id="popup-overlay" style="display: none;">
      <div class="popup-content">
          <h2>Tips!</h2>
          <ul>
              <li>Drag your mouse around the screen to move the camera.</li>
              <li>Right-click or hold f over a cell to flag it.</li>
              <li>Left-click on a cell to reveal it.</li>
              <li>Flag all the mines to win the game.</li>
              <br>
              <li>The timer starts when you either flag or click a cell.</li>
              <li>Reloading the page will pause the timer until you make the next move.</li>
          </ul>
          <button id="closePopup">Close</button>
      </div>
    </div>
    <div class="popup-overlay" id="bug-overlay" style="display: none;">
      <div class="popup-content">
          <h2>Please report any bugs you find to inlowik@gmail.com!</h2>
          <p>Any and all reports or welcome, and you can also email to suggest changes or ideas you may have!</p>
          <button id="closePopup2">Close</button>
      </div>
    </div>
      <div class="titlebox" id="title-box">
          <h1>3D-ish Minesweeper</h1>
          <p>Built by <a href="https://github.com/EdwardLuoJihan" target="_blank">me</a></p>
          <p>Enjoy!</p>
          <button onclick="setLevel(-1)">Restart</button><br><br>
          <a href="https://minesweepergame.com/strategy/how-to-play-minesweeper.php" target="_blank">How to play minesweeper?</a>
      </div>
        <div class="overlay" id="overlay">
            <div class="box">
                <h1 id='msg'>You Lost!</h1>
                <p id="timetaken"></p>
                <button onclick="resetGame();">Play Again</button>
            </div>
        </div>
        <div class="grid" id="grid">
            {{html | safe}}
        </div>
        <script>
            const toggleButton = document.getElementById('togglemode');

// Function to update the button text
function updateButtonText() {
    if (document.body.classList.contains('darkmode')) {
        toggleButton.textContent = 'üåû';
    } else {
        toggleButton.textContent = 'üåô';
    }
}

// Function to toggle dark mode and save preference
function toggleDarkMode() {
    document.body.classList.toggle('darkmode');
    updateButtonText();

    // Apply dark mode class to all specified elements
    const elements = document.querySelectorAll('.surface, .flagged, .empty, .g, .y, .r, .mine, button, #time, #t, .minimize, .helppopup, .bugpopup');
    elements.forEach(element => {
        element.classList.toggle('darkmode');
    });

    // Save preference to local storage
    if (document.body.classList.contains('darkmode')) {
        localStorage.setItem('darkmode', 'enabled');
    } else {
        localStorage.removeItem('darkmode');
    }
}

// Add event listener to the button
toggleButton.addEventListener('click', toggleDarkMode);

// Check local storage for dark mode preference on page load
if (localStorage.getItem('darkmode') === 'enabled') {
    document.body.classList.add('darkmode');
    // Apply dark mode class to specified elements
    const elements = document.querySelectorAll('.surface, .flagged, .empty, .g, .y, .r, .mine, button, #time, #t, .minimize, .helppopup, .bugpopup');
    elements.forEach(element => {
        element.classList.add('darkmode');
    });
}

// Initialize button text based on current mode
updateButtonText();



          let hoveredCell = null; // Variable to track the hovered cell

// Function to track the hovered cell
function handleMouseOverCell(event) {

    const cell = event.target; 
    const row = cell.getAttribute("data-row");
    const col = cell.getAttribute("data-col");
    if (row && col) {
        hoveredCell = { row, col };
    }
    console.log(hoveredCell)
}

// Function to clear the hovered cell when the mouse leaves
function handleMouseOutCell() {
    hoveredCell = null;
}

// Function to flag/unflag a cell when "F" key is pressed
function handleFlagKey(event) {
    if (event.key === "f" || event.key === "F") {
        if (hoveredCell) {
            const { row, col } = hoveredCell;
            // Simulate a flag action (you can adjust this to trigger your flagging logic)
            flagCell(row, col); 
        }
    }
}

// Function to handle flagging a cell
function flagCell(row, col) {
    const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    const isFlagged = cellElement.classList.contains('flagged'); 
    startTimer();

    // Perform the flag/unflag action
    if (!isFlagged) {
        // Send flag/unflag data to the server (adjust this with your existing logic)
        sendFlagRequest(row, col, false, cellElement);
    } else {
        sendFlagRequest(row, col, true, cellElement);
    }
}

// Function to send the flag/unflag request to the server
function sendFlagRequest(row, col, flagged, surface) {
    fetch('/handle_flag', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ row, col, flagged })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log("Flag action successful");
            document.getElementById('flags').innerText = data.flags;
                            document.getElementById('total').innerText = data.nm;
                            // Toggle the 'flagged' class if the backend responds with success
                            if(data.state) {
                              surface.classList.add('flagged');
                            } else {
                              surface.classList.remove('flagged');
                            }
                          if (data.win) {
                            document.getElementById('overlay').style.display = 'block';
                            document.getElementById('msg').innerText = 'You Won!';
                            stopTimer();
                            document.getElementById('timetaken').innerHTML = `Time Taken: <span id='t'>${elapsedTime}</span> s <br><br>`;
                            resetTimer();
                           const gameBoard = data.game_board;

                           // Update the board based on revealed cells
                           data.revealed.forEach(cell => {
                               const [revealedRow, revealedCol] = cell;  // Unpack row and col
                               const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                               if (revealedCell) {
                                   revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                   const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                 if (cellValue == 0) {
                                   revealedCell.classList.add('empty');
                                   revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                 } else {
                                  if(cellValue == 'M') {
                                    revealedCell.classList.add('mine');
                                  }
                                  if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                   revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                 }
                               }
                           });
                          }
        } else {
            console.log("Flag action failed");
        }
    })
    .catch(error => console.error('Error:', error));
}

          // Function to toggle settings box
function toggleSettings() {
    const settingsBox = document.getElementById("settings-box");
    const settingsContent = document.getElementById("settings-box");
    const minimizeBtn = document.getElementById("minimize-btn");

    if (settingsContent.style.display === "none") {
        settingsContent.style.display = "block";
        minimizeBtn.style.display = "block!important";
        minimizeBtn.innerHTML = "<p>-</p>";
        localStorage.setItem("settingsMinimized", "false"); // Store in local storage
    } else {
        settingsContent.style.display = "none";
        minimizeBtn.innerHTML = "<p>+</p>";
        localStorage.setItem("settingsMinimized", "true"); // Store in local storage
    }
}
function toggleSettings2() {
    const t = document.getElementById("title-box");
    const minimizeBtn2 = document.getElementById("minimize-btn2");
    const stats = document.getElementById("statsbox");

    if (t.style.display === "none") {
        t.style.display = "block";
        minimizeBtn2.style.display = "block!important";
        minimizeBtn2.innerHTML = "<p>-</p>";
        stats.style.left = '517px';
        localStorage.setItem("settingsMinimized2", "false"); // Store in local storage
    } else {
        t.style.display = "none";
        minimizeBtn2.innerHTML = "<p>+</p>";
        stats.style.left = '50px';
        localStorage.setItem("settingsMinimized2", "true"); // Store in local storage
    }
}

// On page load, check if settings were minimized or not
document.addEventListener("DOMContentLoaded", function() {
  // Event listeners for mouseover and mouseout on the cells
document.querySelectorAll('.surface').forEach(cell => {
    cell.addEventListener('mouseover', handleMouseOverCell);
    cell.addEventListener('mouseout', handleMouseOutCell);
});

// Event listener for the "F" key press
document.addEventListener('keydown', handleFlagKey);
    const settingsMinimized = localStorage.getItem("settingsMinimized");
    const settingsContent = document.getElementById("settings-box");
    const minimizeBtn = document.getElementById("minimize-btn");
    const t = localStorage.getItem("settingsMinimized2");
    const t1 = document.getElementById("title-box");
    const t2 = document.getElementById("minimize-btn2");
    const stats = document.getElementById("statsbox");

    if (settingsMinimized === "true") {
        settingsContent.style.display = "none";
        minimizeBtn.innerHTML = "<p>+</p>";
    } else {
        settingsContent.style.display = "block";
        minimizeBtn.innerHTML = "<p>-</p>";
    }

    if (t === "true") {
        t1.style.display = "none";
        t2.innerHTML = "<p>+</p>";
        stats.style.left = '50px';
    } else {
        t1.style.display = "block";
        stats.style.left = '517px';
        t2.innerHTML = "<p>-</p>";
    }
});
// Toggle the help popup
document.getElementById("helppopup").addEventListener("click", function () {
    const popupOverlay = document.getElementById("popup-overlay");
    if (popupOverlay.style.display === "none" || popupOverlay.style.display === "") {
        popupOverlay.style.display = "flex"; // Show popup
    } else {
        popupOverlay.style.display = "none"; // Hide popup
    }
});

// Close the help popup when the close button is clicked
document.getElementById("closePopup").addEventListener("click", function () {
    document.getElementById("popup-overlay").style.display = "none";
});

// Toggle the help popup
document.getElementById("bugpopup").addEventListener("click", function () {
    const popupOverlay = document.getElementById("bug-overlay");
    if (popupOverlay.style.display === "none" || popupOverlay.style.display === "") {
        popupOverlay.style.display = "flex"; // Show popup
    } else {
        popupOverlay.style.display = "none"; // Hide popup
    }
});

// Close the help popup when the close button is clicked
document.getElementById("closePopup2").addEventListener("click", function () {
    document.getElementById("bug-overlay").style.display = "none";
});

          let timer; // Variable to store the timer
let elapsedTime = parseInt(localStorage.getItem('elapsedTime')) || 0; // Track elapsed time in seconds, default to 0 if not set
let timerRunning = false; // Flag to track if the timer is running

// Function to start the timer
function startTimer() {
    if (!timerRunning) { // Only start if the timer is not already running
        timerRunning = true; // Set the flag to true
        timer = setInterval(() => {
            elapsedTime++; // Increment the elapsed time
            localStorage.setItem('elapsedTime', elapsedTime); // Store elapsed time in localStorage
            document.getElementById("time").textContent = elapsedTime; // Update the time display
        }, 1000); // Update every second
    }
}

// Function to stop the timer
function stopTimer() {
    clearInterval(timer); // Stop the timer
    timerRunning = false; // Reset the flag
}

// Load elapsed time from localStorage on page load
document.addEventListener("DOMContentLoaded", () => {
    document.getElementById("time").textContent = elapsedTime; // Display stored time
});

// Call this function to reset the timer when starting a new game
function resetTimer() {
    stopTimer(); // Stop the current timer
    elapsedTime = 0; // Reset elapsed time
    localStorage.removeItem('elapsedTime'); // Clear elapsed time from localStorage
    document.getElementById("time").textContent = elapsedTime; // Update the display
}


          function setLevel(level) {
        fetch("/set_level", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ level: level })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
              let hoveredCell = null;
              resetTimer();
              console.log(hoveredCell)
              // Event listeners for mouseover and mouseout on the cells
              console.log('attempting to add mouseovermouseout')
          

              // Event listener for the "F" key press
              document.addEventListener('keydown', handleFlagKey);
              
                document.getElementById("grid").innerHTML = data.html;
                document.getElementById('flags').innerText = data.flags;
                document.getElementById('total').innerText = data.nm;
                // Check local storage for dark mode preference on page load
if (localStorage.getItem('darkmode') === 'enabled') {
    document.body.classList.add('darkmode');
    // Apply dark mode class to specified elements
    const elements = document.querySelectorAll('.surface, .flagged, .empty, .g, .y, .r, .mine, button, #time, #t, .minimize, .helppopup, .bugpopup');
    elements.forEach(element => {
        element.classList.add('darkmode');
    });
}

// Initialize button text based on current mode
updateButtonText();

                // Attach click event listener to each .surface element
                document.querySelectorAll('.surface').forEach(function(surface) {
                    surface.addEventListener('click', function() {
                      startTimer();
                      if (!isDragging) {
                        // Get the cell coordinates (you'll need to encode the coordinates in the div attributes)
                        const row = surface.getAttribute('data-row');
                        const col = surface.getAttribute('data-col');

                      const isFlagged = surface.classList.contains('flagged');


                       if (!isFlagged) {
                         // Send a POST request to Flask with the row and column
                         fetch('/handle_click', {
                             method: 'POST',
                             headers: {
                                 'Content-Type': 'application/json'
                             },
                             body: JSON.stringify({ row: row, col: col })
                         })
                         .then(response => response.json())
                         .then(data => {
                             // Update the board or handle the Minesweeper logic based on the response
                             if (data.success) {
                                 const gameBoard = data.game_board;

                                 // Update the board based on revealed cells
                                 data.revealed.forEach(cell => {
                                     const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                     const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                     if (revealedCell) {
                                         revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                         const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                       if (cellValue == 0) {
                                         revealedCell.classList.add('empty');
                                         revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                       } else {
                                         if(cellValue == "M") {
                                           revealedCell.classList.add('mine');
                                         } else {

                                          if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }

                                          revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                        }
                                       }
                                     }
                                 });
                             } else {
                               if (data.gameover) {
                                 document.getElementById('overlay').style.display = 'block';
                                 document.getElementById('msg').innerText = 'You Lost!';
                                 stopTimer()
                                 const gameBoard = data.game_board;
                                 console.log(gameBoard)

                                  // Update the board based on revealed cells
                                  data.revealed.forEach(cell => {
                                      const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                      const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                      if (revealedCell) {
                                          revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                          const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                        if (cellValue == 0) {
                                          revealedCell.classList.add('empty');
                                          revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                        } else {
                                          if(cellValue == "M") {
                                             revealedCell.classList.add('mine');
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                           } else {
                                            if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;}
                                        }
                                      }
                                  });

                               }
                             }
                         })
                         .catch(error => {
                             console.error("Request failed", error);
                         });
                       }
                      } });

                });
                document.querySelectorAll('.surface').forEach(cell => {
                console.log(cell)
                  cell.addEventListener('mouseover', handleMouseOverCell);
                  cell.addEventListener('mouseout', handleMouseOutCell);
              });
                document.querySelectorAll('.surface').forEach(function(surface) {
                surface.addEventListener('contextmenu', function(event) {
                  startTimer();
                  if (!isDragging) {
                    const row = surface.getAttribute('data-row');
                    const col = surface.getAttribute('data-col');

                    // Determine whether to flag or unflag
                    const isFlagged = surface.classList.contains('flagged');

                    // Send the request to the backend to handle flagging
                    fetch('/handle_flag', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            row: row,
                            col: col,
                            flagged: isFlagged  // If it's already flagged, we are unflagging, and vice versa
                        }),
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('flags').innerText = data.flags;
                            document.getElementById('total').innerText = data.nm;
                            // Toggle the 'flagged' class if the backend responds with success
                            if(data.state) {
                              surface.classList.add('flagged');
                            } else {
                              surface.classList.remove('flagged');
                            }
                          if (data.win) {
                            document.getElementById('overlay').style.display = 'block';
                            document.getElementById('msg').innerText = 'You Won!';
                            stopTimer();
                            document.getElementById('timetaken').innerHTML = `Time Taken: <span id='t'>${elapsedTime}</span> s <br><br>`;
                            resetTimer();
                           const gameBoard = data.game_board;

                           // Update the board based on revealed cells
                           data.revealed.forEach(cell => {
                               const [revealedRow, revealedCol] = cell;  // Unpack row and col
                               const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                               if (revealedCell) {
                                   revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                   const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                 if (cellValue == 0) {
                                   revealedCell.classList.add('empty');
                                   revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                 } else {
                                  if(cellValue == 'M') {
                                    revealedCell.classList.add('mine');
                                  }
                                  if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                   revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                 }
                               }
                           });
                          }

                        } else {
                            console.error('Error flagging/unflagging:', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });
                  }
                });
            });
                const surfaces = document.querySelectorAll('.surface');


    surfaces.forEach((surface, index) => {
        setTimeout(() => {
          surface.style.transform = 'translate3d(0, 0, 0) rotateX(51deg) rotateZ(45deg)';
            surface.style.opacity = 1; // Reveal the surface
        }, index * 10); // Adjust the timing as needed (500ms per element)
    });

            }
        })
        .catch(error => console.error('Error:', error));
    }

document.addEventListener('DOMContentLoaded', () => {
    const surfaces = document.querySelectorAll('.surface');

    surfaces.forEach((surface, index) => {
        setTimeout(() => {
          surface.style.transform = 'translate3d(0, 0, 0) rotateX(51deg) rotateZ(45deg)';
            surface.style.opacity = 1; // Reveal the surface
        }, index * 10); // Adjust the timing as needed (500ms per element)
    });
});
            window.addEventListener('wheel', function(event) {
                event.preventDefault();
            }, { passive: false });


            // Disable zoom on all devices
            document.addEventListener('wheel', function(event) {
              if (event.ctrlKey) {
                event.preventDefault();
              }
            }, { passive: false });

            document.addEventListener('keydown', function(event) {
              if (event.ctrlKey && (event.key === '+' || event.key === '-' || event.key === '0')) {
                event.preventDefault();
              }
            });
            // Make the DIV element draggable:
            dragElement(document.getElementById("grid"));

            // Call the function to make the body draggable
            dragBody();
            let isDragging = false;

            function dragElement(elmnt) {
              var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

              // Move the DIV from anywhere inside the DIV:
              elmnt.onmousedown = dragMouseDown;

              function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                document.body.style.cursor = "grabbing";
                isDragging = true;
                // get the mouse cursor position at startup:
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = elementDrag;

              }

              function elementDrag(e) {
                  e = e || window.event;
                  e.preventDefault();

                  // calculate the new cursor position:
                  pos1 = pos3 - e.clientX;
                  pos2 = pos4 - e.clientY;
                  pos3 = e.clientX;
                  pos4 = e.clientY;

                  // Get the current position and dimensions of the grid
                  const grid = elmnt;
                  const gridRect = grid.getBoundingClientRect();
                  const viewportWidth = window.innerWidth;
                  const viewportHeight = window.innerHeight;

                  // Calculate new position
                  let newTop = grid.offsetTop - pos2;
                  let newLeft = grid.offsetLeft - pos1;

                  // Ensure at least part of the grid is within the viewport
                  if (newTop + gridRect.height < 0) {
                      newTop = -gridRect.height + 1; // Allow the grid to be dragged slightly outside at the top
                  } else if (newTop > viewportHeight) {
                      newTop = viewportHeight - 1; // Allow the grid to be dragged slightly outside at the bottom
                  }

                  if (newLeft + gridRect.width < 0) {
                      newLeft = -gridRect.width + 1; // Allow the grid to be dragged slightly outside on the left
                  } else if (newLeft > viewportWidth) {
                      newLeft = viewportWidth - 1; // Allow the grid to be dragged slightly outside on the right
                  }

                  // Ensure at least part of the grid is visible in the viewport
                  if (newTop > 100) {
                      newTop = Math.max(0, newTop); // Limit to top if fully visible
                  } else if (newTop + gridRect.height < viewportHeight) {
                      newTop = Math.min(viewportHeight - gridRect.height, newTop); // Limit to bottom if fully visible
                  }

                  if (newLeft > 0) {
                      newLeft = Math.max(0, newLeft); // Limit to left if fully visible
                  } else if (newLeft + gridRect.width < viewportWidth) {
                      newLeft = Math.min(viewportWidth - gridRect.width, newLeft); // Limit to right if fully visible
                  }

                  // set the element's new position:
                  grid.style.top = newTop + "px";
                  grid.style.left = newLeft + "px";
              }

              function closeDragElement() {
                // stop moving when mouse button is released:
                document.onmouseup = null;
                isDragging = false;
                document.onmousemove = null;
                document.body.style.cursor = "grab";
              }
            }

            function dragBody() {
              var body = document.body;
              var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

              body.onmousedown = dragMouseDown;

              function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // get the mouse cursor position at startup:
                document.body.style.cursor = "grabbing";
                isDragging = true;
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = bodyDrag;
              }

              function bodyDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // calculate the new cursor position:
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                // Get the current position and dimensions of the grid
                const grid = document.getElementById("grid");
                const gridRect = grid.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Calculate new position
                let newTop = grid.offsetTop - pos2;
                let newLeft = grid.offsetLeft - pos1;

                // Ensure at least part of the grid is within the viewport
                if (newTop + gridRect.height < 0) {
                  newTop = -gridRect.height + 1; // Allow the grid to be dragged slightly outside at the top
                } else if (newTop > viewportHeight) {
                  newTop = viewportHeight - 1; // Allow the grid to be dragged slightly outside at the bottom
                }

                if (newLeft + gridRect.width < 0) {
                  newLeft = -gridRect.width + 1; // Allow the grid to be dragged slightly outside on the left
                } else if (newLeft > viewportWidth) {
                  newLeft = viewportWidth - 1; // Allow the grid to be dragged slightly outside on the right
                }

                // Ensure at least part of the grid is visible in the viewport
                if (newTop > 0) {
                  newTop = Math.max(0, newTop); // Limit to top if fully visible
                } else if (newTop + gridRect.height < viewportHeight) {
                  newTop = Math.min(viewportHeight - gridRect.height, newTop); // Limit to bottom if fully visible
                }

                if (newLeft > 0) {
                  newLeft = Math.max(0, newLeft); // Limit to left if fully visible
                } else if (newLeft + gridRect.width < viewportWidth) {
                  newLeft = Math.min(viewportWidth - gridRect.width, newLeft); // Limit to right if fully visible
                }

                // set the grid's new position:
                grid.style.top = newTop + "px";
                grid.style.left = newLeft + "px";
              }

              function closeDragElement() {
                // stop moving when mouse button is released:
                document.onmouseup = null;
                document.onmousemove = null;
                document.body.style.cursor = "grab";
                isDragging = false;
              }
            }

            document.addEventListener('contextmenu', function(event) {
                event.preventDefault();
            });
            document.querySelectorAll('.surface').forEach(function(surface) {
                surface.addEventListener('contextmenu', function(event) {
                  startTimer();

                  if (!isDragging) {
                    const row = surface.getAttribute('data-row');
                    const col = surface.getAttribute('data-col');

                    // Determine whether to flag or unflag
                    const isFlagged = surface.classList.contains('flagged');

                    // Send the request to the backend to handle flagging
                    fetch('/handle_flag', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            row: row,
                            col: col,
                            flagged: isFlagged  // If it's already flagged, we are unflagging, and vice versa
                        }),
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('flags').innerText = data.flags;
                            document.getElementById('total').innerText = data.nm;
                            // Toggle the 'flagged' class if the backend responds with success
                            if(data.state) {
                              surface.classList.add('flagged');
                            } else {
                              surface.classList.remove('flagged');
                            }
                          if (data.win) {
                            document.getElementById('overlay').style.display = 'block';
                            document.getElementById('msg').innerText = 'You Won!';
                            stopTimer();
                            document.getElementById('timetaken').innerHTML = `Time Taken: <span id='t'>${elapsedTime}</span> s <br><br>`;
                            resetTimer();
                           const gameBoard = data.game_board;

                           // Update the board based on revealed cells
                           data.revealed.forEach(cell => {
                               const [revealedRow, revealedCol] = cell;  // Unpack row and col
                               const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                               if (revealedCell) {
                                   revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                   const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                 if (cellValue == 0) {
                                   revealedCell.classList.add('empty');
                                   revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                 } else {
                                  if(cellValue == 'M') {
                                    revealedCell.classList.add('mine');
                                  }
                                  if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }
                                   revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                 }
                               }
                           });
                          }

                        } else {
                            console.error('Error flagging/unflagging:', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });
                  }
                });
            });
            document.addEventListener('DOMContentLoaded', function() {
                // Get all elements with the class 'surface'
                const surfaces = document.querySelectorAll('.surface');

                // Attach click event listener to each .surface element
                surfaces.forEach(function(surface) {
                    surface.addEventListener('click', function() {
                      startTimer();
                      if (!isDragging) {
                        // Get the cell coordinates (you'll need to encode the coordinates in the div attributes)
                        const row = surface.getAttribute('data-row');
                        const col = surface.getAttribute('data-col');

                      const isFlagged = surface.classList.contains('flagged');


                       if (!isFlagged) {
                         // Send a POST request to Flask with the row and column
                         fetch('/handle_click', {
                             method: 'POST',
                             headers: {
                                 'Content-Type': 'application/json'
                             },
                             body: JSON.stringify({ row: row, col: col })
                         })
                         .then(response => response.json())
                         .then(data => {
                             // Update the board or handle the Minesweeper logic based on the response
                             if (data.success) {
                                 const gameBoard = data.game_board;

                                 // Update the board based on revealed cells
                                 data.revealed.forEach(cell => {
                                     const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                     const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                     if (revealedCell) {
                                         revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                         const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                       if (cellValue == 0) {
                                         revealedCell.classList.add('empty');
                                         revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                       } else {
                                         if(cellValue == "M") {
                                           revealedCell.classList.add('mine');
                                         } else {

                                          if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }

                                          revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                        }
                                       }
                                     }
                                 });
                             } else {
                               if (data.gameover) {
                                 document.getElementById('overlay').style.display = 'block';
                                 document.getElementById('msg').innerText = 'You Lost!';
                                 stopTimer()
                                 const gameBoard = data.game_board;
                                 console.log(gameBoard)

                                  // Update the board based on revealed cells
                                  data.revealed.forEach(cell => {
                                      const [revealedRow, revealedCol] = cell;  // Unpack row and col
                                      const revealedCell = document.querySelector(`.surface[data-row="${revealedRow}"][data-col="${revealedCol}"]`);
                                      if (revealedCell) {
                                          revealedCell.classList.add('revealed');  // Add a class for revealed styling
                                          const cellValue = gameBoard[revealedRow][revealedCol];  // Get the value (0, 1, 2, M, etc.)
                                        if (cellValue == 0) {
                                          revealedCell.classList.add('empty');
                                          revealedCell.innerHTML = `<span class="surfacetext"></span>`;
                                        } else {
                                          if(cellValue == "M") {
                                             revealedCell.classList.add('mine');
                                           } else {
                                            if(cellValue == 1) {
                                            revealedCell.classList.add('g');
                                          } if(cellValue == 2) {
                                            revealedCell.classList.add('y');
                                          }  if(cellValue > 2) {
                                            revealedCell.classList.add('r');
                                          }}
                                          console.log(revealedCell)
                                            revealedCell.innerHTML = `<span class="surfacetext">${cellValue}</span>`;
                                        }
                                      }
                                  });
                               }
                             }
                         })
                         .catch(error => {
                             console.error("Request failed", error);
                         });
                       }
                      } });

                });
            });






            function resetGame() {
              console.log('reset called')
                fetch('/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update the HTML with the new game state
                        document.querySelector('.grid').innerHTML = data.html;
                    } else {
                        console.error('Error resetting the game:');
                    }
                    location.reload();
                    resetTimer();
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }
        </script>
    </body>
</html>